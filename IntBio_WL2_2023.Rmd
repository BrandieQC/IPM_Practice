---
title: "IntBio_WL2_2023"
author: "Brandie QC"
date: "`r Sys.Date()`"
output: 
  html_document: 
    keep_md: true
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Make a practice IPM with WL2 2023 Data

To Do:

-   Check P matrix since I ran the models with scaled and transformed
    data, but did not account for that when making the P matrix
-   Make a separate P matrix for each pop to take into account random
    slopes

## Libraries

```{r}
library(tidyverse)
library(broom)
library(broom.mixed)
library(magrittr)
library(lmerTest)
conflicted::conflicts_prefer(lmerTest::lmer)
conflicted::conflicts_prefer(dplyr::filter)
```

## Load the data

```{r}
wl2_size_2023 <- read_csv("data/WL2-2023_Size_Combined.csv") %>% select(survey_date, Genotype, parent.pop, height.cm, long.leaf.cm)
unique(wl2_size_2023$parent.pop) #all 23 pops!
wl2_mort_2023 <- read_csv("data/WL2_Mortality_2023.csv") %>% 
  select(block, BedLoc, Genotype, parent.pop=pop, mf:death.date) %>% 
  mutate(parent.pop= str_replace(parent.pop, "Y08", "YO8")) %>% 
  mutate(parent.pop= str_replace(parent.pop, "Y04", "YO4")) %>% 
mutate(Genotype= str_replace(Genotype, "Y08", "YO8")) %>% 
  mutate(Genotype= str_replace(Genotype, "Y04", "YO4")) 
unique(wl2_mort_2023$parent.pop) #all 23 pops!

#wl2_size_2023 %>% filter(Genotype=="YO4_2_2") #I_18_C
#wl2_size_2023 %>% filter(Genotype=="YO8_8_4") #B_58_A

#wl2_mort_2023 %>% filter(Genotype=="YO4_2_2")
#wl2_mort_2023 %>% filter(BedLoc=="I_18_C")
#wl2_mort_2023 %>% filter(BedLoc=="B_58_A")

wl2_fruits_2023 <- read_csv("data/WL2_2023_Fruits_forIPMs.csv") %>% 
  rename(parent.pop=pop) %>% 
  filter(BedLoc!="K_5_C") %>% #get rid of duplicate locations
  filter(BedLoc!="B_32_A") %>% #get rid of duplicate locations
  filter(!is.na(parent.pop), !str_detect(Genotype, ".*buff*"))  #remove buffers 
unique(wl2_fruits_2023$parent.pop) #only TM2 made fruits

wl2_phenology_2023 <- read_csv("data/WL2_2023_PhenologyDates.csv") %>% 
  unite("BedLoc", bed:bed.col, remove = FALSE) %>% 
  unite("Genotype", pop:rep, remove = FALSE) %>% 
  rename(parent.pop=pop) %>% 
  filter(BedLoc!="K_5_C") %>% #get rid of duplicate locations
  filter(BedLoc!="B_32_A") %>% #get rid of duplicate locations
  filter(!is.na(parent.pop), !str_detect(Genotype, ".*buff*"))  #remove buffers 
unique(wl2_phenology_2023$parent.pop)
```

## Merge

```{r}
wl2_all_2023_OLD <- left_join(wl2_size_2023, wl2_mort_2023) #42 more rows, why? duplicate rows somewhere 
wl2_all_2023_OLD %>% group_by(Genotype, survey_date) %>% summarise(n=n()) %>% arrange(desc(n)) 
##Duplicates: CC_1_2, CC_9_6, IH_4_5, SC_5_6, SQ2_6_2
wl2_size_2023 %>% filter(Genotype=="CC_1_2") #duplicated on certain dates  
wl2_size_2023 %>% filter(Genotype=="CC_9_6") #duplicated on certain dates  
wl2_size_2023 %>% filter(Genotype=="IH_4_5") #duplicated on certain dates  
wl2_size_2023 %>% filter(Genotype=="SC_5_6") #duplicated on certain dates  
wl2_size_2023 %>% filter(Genotype=="SQ2_6_2") #duplicated on certain dates  

#anti_join(wl2_size_2023, wl2_mort_2023) #8 rows in the size dataframe without death date info, probably died at planting 
#anti_join(wl2_mort_2023, wl2_size_2023)

#GET RID OF DUPLICATES:
wl2_size_2023_merge_prep <- wl2_size_2023 %>% 
  arrange(Genotype, survey_date, height.cm) %>% 
  distinct(Genotype, survey_date, .keep_all=TRUE)
wl2_size_2023_merge_prep %>% filter(Genotype=="YO4_2_2")

#Merge with corrections 
wl2_all_2023 <- left_join(wl2_size_2023_merge_prep, wl2_mort_2023) %>%
  select(survey_date:parent.pop, mf:rep,block:BedLoc, height.cm, long.leaf.cm, death.date) %>% 
  drop_na(block) #get rid of plants that were not planted and never got a block assigned. 
tail(wl2_all_2023, 10)
unique(wl2_all_2023$death.date)

```

## Add in surv and sizenext columns

```{r}
wl2_all_2023_timeprep <- wl2_all_2023 %>% 
  select(-long.leaf.cm) %>% 
  mutate(death.date=mdy(death.date)) %>% 
  group_by(Genotype) %>% 
  mutate(height_next = lead(height.cm, order_by = survey_date), #next timepoints height
        # survey_date_char = as.character(survey_date), #grouping variable to compare to continuous survey date 
         date_next = lead(survey_date, order_by = survey_date), #needed for surv code and interval calc
         elapsed_days= date_next - survey_date, #interval length in days
         elapsed_weeks = as.integer(elapsed_days)/7, #interval length in weeks 
         surv=if_else(is.na(death.date), 1,
                      if_else(date_next>=death.date, 0, 1))) %>% #survival to the next size time point
  ungroup() %>%
  mutate(week = as.numeric(survey_date - ymd("2023-07-03")), #Weeks since pre-transplant size 
         pop.mf=str_c(parent.pop, "_", mf)) %>% #for specifying random effects separately  
  drop_na(height.cm, height_next, surv) #for models
         
#wl2_all_2023_timeprep %>% arrange(Genotype, survey_date)

unique(wl2_all_2023_timeprep$elapsed_days) #mostly 1 or 2 weeks. 20 or 23 days from initial size measurements on campus to field measurements 
unique(wl2_all_2023_timeprep$week)
unique(wl2_all_2023_timeprep$block)
unique(wl2_all_2023_timeprep$parent.pop)
unique(wl2_all_2023_timeprep$pop.mf)
```

### Scaling and transformations

```{r}
summary(wl2_all_2023_timeprep)
wl2_all_2023_timeprep %>%  #pretty skewed
  ggplot(aes(x=height.cm)) +
  geom_histogram()

wl2_all_2023_timeprep_scaled <- wl2_all_2023_timeprep %>% 
  mutate(logHeight=log(height.cm))  #transform height to be more normal - only for surv models 

wl2_all_2023_timeprep_scaled %>% #better
  ggplot(aes(x=logHeight)) +
  geom_histogram()
```

## Survival Models

Using height as the main size estimate here

Notes:

-   Treating time as a factor not a good idea since we want the models
    to be predictive in other years

    -   Weekly climate variation will be accounted for when we include
        weekly climate data

    -   Time as a random effect in weekly climate models? (to account
        for week to week variance).

### Fixed models

```{r, eval=FALSE}
surv_models_fixed <- tribble(
  ~name,          ~f,
  "1_intercept",              "surv ~ 1", 
  "2a_linear_size",           "surv ~ height.cm", 
  "2b_linear_pops",           "surv ~ parent.pop", 
  "3a_linear_size_date_char", "surv ~ height.cm*survey_date_char",
  "3b_linear_pops_date_char", "surv ~ parent.pop*survey_date_char",
  "3c_linear_pops_date",      "surv ~ parent.pop*survey_date",
  "3d_linear_pops_date",      "surv ~ parent.pop*survey_date",
  "3e_linear_size_pops",      "surv ~ height.cm*parent.pop",
  "4a_linear_size_pops_date_char", "surv ~ height.cm*parent.pop + height.cm*survey_date_char + parent.pop*survey_date_char",
  "4b_linear_size_pops_date", "surv ~ height.cm*parent.pop + height.cm*survey_date + parent.pop*survey_date",
  "5_quadratic_size",         "surv ~ height.cm + I(height.cm^2)", 
  "6_cubic_size",             "surv ~ height.cm + I(height.cm^2) + I(height.cm^3)",
  "7a_quadratic_size_pops",    "surv ~ height.cm*parent.pop + I(height.cm^2)",
  "8a_cubic_size_pops",        "surv ~ height.cm*parent.pop + I(height.cm^2) + I(height.cm^3)",
  "9a_quadratic_full_survey_date_char", "surv ~ height.cm*parent.pop*survey_date_char + I(height.cm^2)", 
  "9b_quadratic_full_survey_date",  "surv ~ height.cm*parent.pop*survey_date + I(height.cm^2)",
  "10a_cubic_full_survey_date_char", "surv ~ height.cm*parent.pop*survey_date_char + I(height.cm^2) + I(height.cm^3)",
  "10b_cubic_full_survey_date", "surv ~ height.cm*parent.pop*survey_date + I(height.cm^2) + I(height.cm^3)"
)


#run the models 
surv_models_fixed <- surv_models_fixed %>%
  mutate(glm = map(f, ~ glm(as.formula(.), 
                            data = wl2_all_2023_timeprep, 
                            family = "binomial")), #run the models 
         predict = map(glm, predict, type = "response"), # predicting from original data...
        # type = response is for glm models, back transforms probabilities from logit scale 
         glance = map(glm, glance)) #glance at the model results

surv_models_fixed %>% select(-f, -glm) %>% unnest(glance) %>% arrange(BIC) #look at the model fitting info 
surv_models_fixed %>% select(-f, -glm) %>% unnest(glance) %>% arrange(AIC) #look at the model fitting info 

#Linear with size and date as a character seems best 
```

```{r, eval=FALSE}
survival.model.final <- surv_models_fixed %>% filter(name == "3a_linear_size_date_char") %>% pull(glm) %>% magrittr::extract2(1)
summary(survival.model.final)
```

#### Predicted vs. Observed Survival

Calculate predictions

```{r, eval=FALSE}
survival_curves <- wl2_all_2023_timeprep %>%
  group_by(survey_date_char) %>%
  summarize(minSize = min(height.cm, na.rm = TRUE),
            maxSize = max(height.cm, na.rm = TRUE)) %>%
  
  # generate a "newdata" data frame for each date
  mutate(newdata = pmap(list(survey_date_char, minSize, maxSize), \(d, x, y) tibble(survey_date_char = d,
                                                        height.cm = seq(x, y, length.out = 101)))) %>%

 # predictions for each date
  mutate(surv = map(newdata, \(nd) predict(survival.model.final, newdata = nd, type = "response"))) %>%
  
  select(-survey_date_char) %>%

  # unnest to plot
  unnest(cols = c(newdata, surv), names_repair = "minimal") 

survival_curves
```

```{r, eval=FALSE}
wl2_all_2023_timeprep %>%
  ggplot(aes(x=height.cm, y = surv)) +
  geom_point() +
  geom_line(color = "red", data = survival_curves) +
  facet_wrap(~survey_date_char, scales = "free_x")
```

### Models with random effects

```{r}
surv.models_random <- tribble(
  ~name,          ~f,
  "1a_intercept_pop_mf_block",     "surv ~ 1 + (1|parent.pop/mf) + (1|block)", 
  "1b_intercept_pop_mf_block2",    "surv ~ 1 + (1|parent.pop) + (1|pop.mf) + (1|block)",  #should be the same as above 
  "2_linear_size_pops_mf_block",   "surv ~ logHeight + (1|block) + (1|parent.pop/mf)", 
  "3_linear_weeks",                "surv ~ logHeight + (1|week) + (1|block) + (1|parent.pop/mf)",
  "4_linear_elapsed_weeks",        "surv ~ logHeight + elapsed_weeks + (1|block) + (1|parent.pop/mf)",
  "5_linear_weeks_all",            "surv ~ logHeight + elapsed_weeks + (1|week) + (1|block) + (1|parent.pop/mf)",
  "6a_quadratic_size",             "surv ~ logHeight + I(logHeight^2) + (1|block) + (1|parent.pop/mf)", 
  "6b_quadratic_size_weeks",       "surv ~ logHeight + I(logHeight^2) + (1|week) + (1|block) + (1|parent.pop/mf)", 
  "7a_cubic_size",                 "surv ~ logHeight + I(logHeight^2) + I(logHeight^3) + (1|block) + (1|parent.pop/mf)",
  "7a_cubic_size_weeks",           "surv ~ logHeight + I(logHeight^2) + I(logHeight^3) + (1|week) + (1|block) + (1|parent.pop/mf)",
  "8a_linear_slope_pop",           "surv ~ logHeight + (logHeight|parent.pop) + (1|pop.mf) + (1|block)",
  "8b_linear_slope_popmf",         "surv ~ logHeight + (1|block) + (logHeight|parent.pop/mf)",
  #"8c_linear_slope_all",          "surv ~ logHeight + (logHeight|block) + (logHeight|parent.pop/mf)",
  "8d_linear_slope_pop_week",      "surv ~ logHeight + (logHeight|parent.pop) + (1|pop.mf) + (1|week) + (1|block)" ,
  #"9_quad_slope",                 "surv ~ logHeight + I(logHeight^2) + (1|block) + (1|pop.mf) + (logHeight+I(logHeight^2)|parent.pop)"
)

#run the models 
#mod_test <- glmer(surv ~ logHeight + (1|week) + (1|block) + (1|parent.pop/mf), family="binomial", data=wl2_all_2023_timeprep_scaled)
#summary(mod_test)
#boundary (singular) fit: see help('isSingular') - linear slope pop, linear slope popmf, & linear slope pop w/ week, maybe b/c little var explained by pop slopes 
#Warning: Model failed to converge with max|grad| = 0.0118026 (tol = 0.002, component 1) - linear slope all 
#Warning: Model failed to converge with max|grad| = 0.0163605 (tol = 0.002, component 1) - quad slope

surv.models_random <- surv.models_random %>%
  mutate(glmer = map(f, ~ glmer(as.formula(.), 
                            data = wl2_all_2023_timeprep_scaled, 
                            family = "binomial")), #, #run the models 
         predict = map(glmer, predict, type = "response", re.form = ~ (1|parent.pop)), 
         glance = map(glmer, tidy),
         AIC = map(glmer, AIC),
         BIC = map(glmer, BIC)) #glance at the model results

surv.models_random %>% select(-f, -glmer, -predict) %>% filter(name=="1a_intercept_pop_mf_block" | name=="1b_intercept_pop_mf_block2") %>% unnest(glance) #first two models are the same as expected 
surv.models_random %>% select(-f, -glmer, -predict) %>% unnest(BIC) %>% arrange(BIC) #look at the model fitting info 
surv.models_random %>% select(-f, -glmer, -predict) %>% unnest(AIC) %>% arrange(AIC) #look at the model fitting info 

#3_linear_weeks wins with BIC
#5_linear_weeks_all wins with AIC - but 3_linear_weeks not too far behind so go with simpler model?
```

```{r}
survival.model.final_random <- surv.models_random %>% filter(name == "3_linear_weeks") %>% pull(glmer) %>% magrittr::extract2(1)
summary(survival.model.final_random)


```

#### Predicted vs. Observed Survival

Note that this is with the transformed height

```{r}
wl2_all_2023_timeprep_scaled %>% 
  mutate(pred_fixef = predict(survival.model.final_random, newdata = ., type="response", re.form = NA), 
        pred_ranef = predict(survival.model.final_random, newdata = ., type="response", re.form = ~(1|parent.pop))) %>% 
  ggplot(aes(x = logHeight, y = surv)) +
  geom_point(alpha=.2) +
  geom_line(aes(y = pred_fixef), 
            color = "blue", 
            size = 1.2, alpha=0.3) +
  geom_line(aes(y = pred_ranef), 
            color = "green", 
            size = 1.2, alpha=0.5) +
  facet_wrap(~parent.pop, scales="free")
```

## Growth Models

### Observed Patterns

```{r}
wl2_all_2023_timeprep %>% 
  #filter(elapsed_days==7) %>% 
  ggplot(aes(x=height.cm, y=height_next)) +
  geom_point(aes(color = parent.pop), alpha=.1)  +
  scale_color_viridis_d(end = 0.9) + 
  geom_abline() +
  geom_smooth(method = "lm")
```

### Fixed effects models

```{r, eval=FALSE}
growth_models_fixed <- tribble(
  ~name,          ~f,
  "1_intercept",              "height_next ~ 1", 
  "2a_linear_size",            "height_next ~ height.cm", 
  "2b_linear_pops",            "height_next ~ parent.pop",
  "3a_linear_with_weeks",      "height_next ~ elapsed_weeks",
  "3b_linear_with_survey_date_char", "height_next ~ survey_date_char",
  "3c_linear_with_survey_date", "height_next ~ survey_date",
  "4a_linear_with_weeks_pops_2way", "height_next ~ height.cm*elapsed_weeks + height.cm*parent.pop + elapsed_weeks*parent.pop",
  "4b_linear_with_survey_date_char_pops_2way", "height_next ~ height.cm*survey_date_char + height.cm*parent.pop + survey_date_char*parent.pop",
  "4c_linear_with_survey_date_pops_2way", "height_next ~ height.cm*survey_date + height.cm*parent.pop + survey_date*parent.pop",
  "5_quadratic_size",         "height_next ~ height.cm + I(height.cm^2)", 
  "6_cubic_size",             "height_next ~ height.cm + I(height.cm^2) + I(height.cm^3)",
  "7a_quadratic_full_weeks",    "height_next ~ height.cm*parent.pop*elapsed_weeks + I(height.cm^2)", 
  "7b_quadratic_full_survey_date_char",    "height_next ~ height.cm*parent.pop*survey_date_char + I(height.cm^2)", 
  "7c_quadratic_full_survey_date",    "height_next ~ height.cm*parent.pop*survey_date + I(height.cm^2)", 
  "8a_cubic_full_weeks",        "height_next ~ height.cm*parent.pop*elapsed_weeks + I(height.cm^2) + I(height.cm^3)",
  "8b_cubic_full_survey_date_char",        "height_next ~ height.cm*parent.pop*survey_date_char + I(height.cm^2) + I(height.cm^3)",
  "8c_cubic_full_survey_date",        "height_next ~ height.cm*parent.pop*survey_date + I(height.cm^2) + I(height.cm^3)"
)

#run the models 
growth_models_fixed <- growth_models_fixed %>%
  mutate(lm = map(f, ~ lm(as.formula(.), data = wl2_all_2023_timeprep)), #run the models 
         predict = map(lm, predict), # predicting from original data...
         glance = map(lm, glance)) #glance at the model results

growth_models_fixed %>% select(-f, -lm) %>% unnest(glance) %>% arrange(BIC) #look at the model fitting info 
growth_models_fixed %>% select(-f, -lm) %>% unnest(glance) %>% arrange(AIC) #look at the model fitting info 
#quadratic with 3way with survey_date as continuous wins by BIC
#cubic with 3way with survey date as character wins by AIC ... Rsquared higher for this model too
```

```{r, eval=FALSE}
growth.model.final <- growth_models_fixed %>% filter(name == "8b_cubic_full_survey_date_char") %>% pull(lm) %>% magrittr::extract2(1)
summary(growth.model.final)
```

#### Predicted vs. Observed Growth

```{r, eval=FALSE}
wl2_all_2023_timeprep %>% 
  cbind(predicted={growth_models_fixed %>% filter(name=="8b_cubic_full_survey_date_char") %>% pull(predict) %>% unlist()}) %>%
  ggplot(aes(x=height_next, y = predicted)) +
  geom_point(alpha=.2) +
  geom_abline(color="skyblue2") +
  facet_wrap(~parent.pop, scales="free")

#looks decent for most pops
```

```{r, eval=FALSE}
wl2_all_2023_timeprep %>% 
  cbind(predicted={growth_models_fixed %>% filter(name=="7c_quadratic_full_survey_date") %>% pull(predict) %>% unlist()}) %>%
  ggplot(aes(x=height_next, y = predicted)) +
  geom_point(alpha=.2) +
  geom_abline(color="skyblue2") +
  facet_wrap(~parent.pop, scales="free")

#looks decent for most pops
#don't see much difference between the two models 
```

### Random effects for Growth

Notes:

-   one direction would be to test a bunch of things, find what works
    best, then add complexity to those to see if it makes a difference

-   alternative would be to start with all the random effects based on
    the exptal design and then add complexity

-   could also do (height.cm + elapsed_weeks\|parent.pop)

```{r}
growth_models_random <- tribble(
  ~name,          ~f,
  "1a_intercept_pop_mf_block",      "height_next ~ 1 + (1|block) +  (1|parent.pop/mf)",
  "1b_intercept_pop_mf_block2",     "height_next ~ 1 + (1|block) +  (1|parent.pop) + (1|pop.mf)", #should be the same as above 
  "2_linear_size_pops_mf_block",    "height_next ~ height.cm + (1|parent.pop/mf) + (1|block)",
  "3_linear_weeks",                 "height_next ~ height.cm + (1|week) + (1|block) + (1|parent.pop/mf)",
  "4a_linear_elapsed_weeks",        "height_next ~ height.cm + elapsed_weeks + (1|block) + (1|parent.pop/mf)",
  "4b_linear_elapsed_weeks_2way",   "height_next ~ height.cm*elapsed_weeks + (1|block) + (1|parent.pop/mf)",
  "5_linear_weeks_all",             "height_next ~ height.cm + elapsed_weeks + (1|week) + (1|block) + (1|parent.pop/mf)",
  "6a_quadratic_size",              "height_next ~ height.cm + I(height.cm^2) + (1|block) + (1|parent.pop/mf)", 
  "6b_quadratic_size_weeks",        "height_next ~ height.cm + I(height.cm^2) + (1|week)+ (1|block) + (1|parent.pop/mf)", 
  #"7a_cubic_size",                  "height_next ~ height.cm + I(height.cm^2) + I(height.cm^3) + (1|block) + (1|parent.pop/mf)",
  #"7b_cubic_size_weeks",            "height_next ~ height.cm + I(height.cm^2) + I(height.cm^3) +  (1|week)+ (1|block) + (1|parent.pop/mf)",
  "8a_linear_slope_pop",            "height_next ~ height.cm + (height.cm|parent.pop) + (1|pop.mf) + (1|block)",
  #"8b_linear_slope_popmf",         "height_next ~ height.cm + (1|block) + (height.cm|parent.pop/mf)",
  #"8c_linear_slope_all",            "height_next ~ height.cm + (height.cm|block) + (height.cm|parent.pop/mf)",
  "8d_linear_slope_pop_week",       "height_next ~ height.cm + (height.cm|parent.pop) + (1|week) + (1|pop.mf) + (1|block)",
  #"9_quad_slope",                 "height_next ~ height.cm + I(height.cm^2) + (1|block) + (1|pop.mf) + (height.cm+I(height.cm^2)|parent.pop)"
)

#run the models 
#mod_test <- lmer(height_next ~ height.cm + I(height.cm^2) + (1|block) + (1|pop.mf) + (height.cm+I(height.cm^2)|parent.pop), data=wl2_all_2023_timeprep_scaled)
#Warning: Some predictor variables are on very different scales: consider rescalingWarning: Some predictor variables are on very different scales: consider rescaling - 7a_cubic_size, 7b_cubic_size_weeks
#Warning: Model failed to converge with max|grad| = 0.00201127 (tol = 0.002, component 1) - 8b_linear_slope_popmf, 8c_linear_slope_all
#boundary (singular) fit: see help('isSingular'); Warning: Model failed to converge with 2 negative eigenvalues: -5.6e+01 -8.0e+01 - 9_quad_slope

growth_models_random <- growth_models_random %>%
  mutate(lmer = map(f, ~ lmer(as.formula(.), data = wl2_all_2023_timeprep_scaled)), #run the models 
         predict = map(lmer, predict, re.form = ~ (1|parent.pop)), # predicting from original data...
         glance = map(lmer, glance)) #glance at the model results

growth_models_random %>% select(-f, -lmer, -predict) %>% filter(name=="1a_intercept_pop_mf_block" | name=="1b_intercept_pop_mf_block2") %>% unnest(glance) #first two models are the same as expected 
growth_models_random %>% select(-f, -lmer) %>% unnest(glance) %>% arrange(BIC) #look at the model fitting info 6b_quadratic_size_weeks wins 
growth_models_random %>% select(-f, -lmer) %>% unnest(glance) %>% arrange(AIC) #look at the model fitting info 8d_linear_slope_pop_week
#go with 8d_linear_slope_pop_week since not that different in BIC from quadratic size? 
```

```{r}
growth.model.final_random <- growth_models_random %>% filter(name == "8d_linear_slope_pop_week") %>% pull(lmer) %>% magrittr::extract2(1)
summary(growth.model.final_random) #positive slope, less than 1 for height, not negative like Jenny
```

#### Predicted vs. Observed Growth

```{r}
wl2_all_2023_timeprep_scaled %>% 
  cbind(predicted_slope={growth_models_random %>% filter(name=="8d_linear_slope_pop_week") %>% pull(predict) %>% unlist()}) %>%
  ggplot(aes(x=height_next, y = predicted_slope)) +
  geom_point(alpha=.2) +
  geom_abline(color="skyblue2") +
  facet_wrap(~parent.pop, scales="free") #decent for most pops

wl2_all_2023_timeprep_scaled %>% 
  cbind(predicted_quad={growth_models_random %>% filter(name=="6b_quadratic_size_weeks") %>% pull(predict) %>% unlist()}) %>%
  ggplot(aes(x=height_next, y = predicted_quad)) +
  geom_point(alpha=.2) +
  geom_abline(color="skyblue2") +
  facet_wrap(~parent.pop, scales="free")
#models not too different from each other 
```

## P Matrix

#### Make a dataframe to store the parameters (as in App A)

```{r}
params=data.frame(
  surv.int=NA, # Intercept from logistic regression of survival
  surv.slope1=NA, # Slope from logistic regression of survival
  growth.int=NA, # Intercept from linear regression of growth
  growth.slope=NA, # Slope from linear regression of growth
  growth.sd=NA # Residual sd from the linear regression of growth
)
```

#### Use broom:tidy to create a df with the coef from each model

```{r}
surv.coefs <- surv.models_random %>% 
  filter(name == "3_linear_weeks") %>% 
  mutate(coefs = map(glmer, tidy)) %>% 
  select(name, f, coefs) %>% 
  unnest(coefs) 

params$surv.int <- surv.coefs %>% filter(term == "(Intercept)") %>% pull(estimate)
params$surv.slope1 <- surv.coefs %>% filter(term == "logHeight") %>% pull(estimate)
```

```{r}
growth.coefs <- growth_models_random %>% 
  filter(name == "8d_linear_slope_pop_week") %>% 
  mutate(coefs = map(lmer, tidy)) %>% 
  select(name, f, coefs) %>% 
  unnest(coefs) 

params$growth.int <- growth.coefs %>% filter(term == "(Intercept)") %>% pull(estimate)
params$growth.slope <- growth.coefs %>% filter(term == "height.cm") %>%  pull(estimate) 

#Pull sigma which is the _modeled_ standard deviation of the residuals.  Merow uses observed sd of residuals.  
params$growth.sd <- growth_models_random %>% filter(name == "8d_linear_slope_pop_week") %>% unnest(glance) %>% pull(sigma)
```

#### Define the functions

```{r}
# 1. survival probability function
##This is inverse logit.  Provides survival probability based on size.
s.x=function(x,params) {
  u=exp(params$surv.int + params$surv.slope1*x)
  return(u/(1+u)) 
}

# 2. growth function
## Return a probability distribution of new sizes at t+1 (xp) at a given size x.  
g.yx=function(xp,x,params) {
  dnorm(xp,mean=params$growth.int+params$growth.slope*x,sd=params$growth.sd)
}
```

#### Define the structure of the IPM

```{r}
# the sizes we are integrating over
minSize<-min(wl2_all_2023_timeprep$height.cm,na.rm=T) 
maxSize<-max(wl2_all_2023_timeprep$height.cm,na.rm=T) 

n=100 # dimensions of the matrix 

b=minSize+c(0:n)*(maxSize-minSize)/n # boundary points
y=0.5*(b[1:n]+b[2:(n+1)]) # mesh points
h=y[2]-y[1] # step size
```

#### Make the matrices (G, S, and P)

```{r}
G=h*outer(y,y,g.yx,params=params) # growth matrix

S=s.x(y,params=params) # survival at each size midpoint

P=G # placeholder; redefine P on the next line
for(i in 1:n) P[,i]=G[,i]*S[i] # growth/survival matrix
```

#### Plot the matrix

```{r}
P %>% as_tibble() %>%
  set_colnames(y) %>% #column names = each size mesh point 
  mutate(size.t1=y) %>%
  pivot_longer(-size.t1, names_to = "size.t", names_transform = as.numeric) %>%
  ggplot(aes(x=size.t, y = size.t1)) +
  geom_raster(aes(fill = value)) + #basic contour with fill determined by the growth*surv value 
  geom_contour(aes(z = value),lwd=.25) + #adds contour lines 
  geom_abline(intercept=0, slope = 1, color="gray90", lty=5) + #add 1:1 line 
  scale_fill_viridis_c(option = "plasma") + #change contour colors 
  labs(x = "Size (t)", y = "Size (t + 1)", title = "P Matrix: Size and Growth") +
  coord_equal() + #make it a square plot 
  theme_bw()
```

#### Check for eviction

Comparison of predicted survival probability to observed values to test
for unintentional eviction. The black line shows the fitted survival
model. The red dot shows the column sums of the growth/survival matrix

```{r}
plot(y,s.x(y,params), #fitted survival model 
     xlab="Size",type="l",
        ylab="Survival Probability",lwd=12)
     points(y,apply(P,2,sum),col="red",lwd=3,cex=.1,pch=19) # column sums 
```

Looks like there is some eviction of small sizes

```{r}
#one way to correct for eviction is to assign all really small indivs to same size class and all really big indivs to same size class
G=h*outer(y,y,g.yx,params=params) # growth matrix
 S=s.x(y,params=params)
 P=G
   # fix eviction of offspring
 for(i in 1:(n/2)) { #All indivs smaller than the lower integration limit are assigned to the smallest size class.
    G[1,i]<-G[1,i]+1-sum(G[,i]) 
    P[,i]<-G[,i]*S[i]
  }

 plot(y,s.x(y,params),xlab="Size",type="l",
        ylab="Survival Probability",lwd=12)
     points(y,apply(P,2,sum),col="red",lwd=3,cex=.1,pch=19) # solution worked
     
P %>% as_tibble() %>%
  set_colnames(y) %>% #column names = each size mesh point 
  mutate(size.t1=y) %>%
  pivot_longer(-size.t1, names_to = "size.t", names_transform = as.numeric) %>%
  ggplot(aes(x=size.t, y = size.t1)) +
  geom_raster(aes(fill = value)) + #basic contour with fill determined by the growth*surv value 
  geom_contour(aes(z = value),lwd=.25) + #adds contour lines 
  geom_abline(intercept=0, slope = 1, color="gray90", lty=5) + #add 1:1 line 
  scale_fill_viridis_c(option = "plasma") + #change contour colors 
  labs(x = "Size (t)", y = "Size (t + 1)", title = "P Matrix: Size and Growth") +
  coord_equal() + #make it a square plot 
  theme_bw()
```

## Fecundity

Questions:

-   What is a good estimate of seeds per fruit? Estimated from F1 crosses data sheet 

-   What is a good estimate of germination probability? Used the one from Appendix C for now

-   What is a good estimate of seedling survival? Used the one from Appendix C for now 

-   Do we want a seedbank? Not for now 

-   What about recruit size? Use the distribution of initial size pre-transplant as recruit size for our practice

-   Flowering prob or budding prob? For 2023, budding prob would at least include FR, for now used flowering

-   What size to use? Use something like 2 months post-transplant (each person can pick their own time point) for predicting probability of flowering and fruit number

### Constants

```{r}
fec2 <- 14 #Number of seeds produced per fruit - estimated from F1 crosses data sheet 

fec3 <- 0.001336 #Probability of germination within the year of seed production

fec4 <- 0.14 #Probability of seedling survival from the time of germination to the time of the next annual census t+1, corresponding to approximately 6 months

#goSB <- 0.08234528 #Probability of a seed entering the seed bank

#staySB <- 0.671 #Probability of a seed staying in the seed bank
```

### Flowering Probability Models

```{r}
probFlw <- wl2_phenology_2023 %>% 
  mutate(ProbFlw=if_else(is.na(flower.date), 0, 1),
         ProbBud=if_else(is.na(bud.date), 0, 1)) %>% 
  select(Genotype, bud.date, ProbBud, flower.date, ProbFlw)
head(probFlw)
```

```{r}
twomossize <- wl2_all_2023 %>% 
  filter(survey_date=="2023-09-13") %>% 
  select(-death.date)
head(twomossize)
```

```{r}
probFlw_size <- left_join(probFlw, twomossize) %>% 
  drop_na(height.cm) %>% 
  mutate(logHeight=log(height.cm)) %>% 
  unite("pop.mf", parent.pop:mf, remove = FALSE)
```

#### Observed Patterns

```{r}
probFlw_size %>% 
  ggplot(aes(x=parent.pop, y=ProbFlw, color=parent.pop)) +
  geom_point() +
  scale_color_viridis_d(end = 0.9) #only TM2 

probFlw_size %>% 
  ggplot(aes(x=parent.pop, y=ProbBud, color=parent.pop)) +
  geom_point() +
  scale_color_viridis_d(end = 0.9) #only TM2 and FR
```

#### Models
```{r}
fec0.models <- tribble(
  ~name,          ~f,
  "1a_intercept_pop_mf_block",     "ProbFlw ~ 1 + (1|parent.pop/mf) + (1|block)", 
  "1b_intercept_pop_mf_block2",    "ProbFlw ~ 1 + (1|parent.pop) + (1|pop.mf) + (1|block)",  #should be the same as above 
  "2_linear_size_pops_mf_block",   "ProbFlw ~ logHeight + (1|block) + (1|parent.pop/mf)", 
  "3_quadratic_size",             "ProbFlw ~ logHeight + I(logHeight^2) + (1|block) + (1|parent.pop/mf)", 
  #"4_cubic_size",                 "ProbFlw ~ logHeight + I(logHeight^2) + I(logHeight^3) + (1|block) + (1|parent.pop/mf)",
  "5_linear_slope_pop",           "ProbFlw ~ logHeight + (logHeight|parent.pop) + (1|pop.mf) + (1|block)",
  #"6_linear_slope_popmf",         "ProbFlw ~ logHeight + (1|block) + (logHeight|parent.pop/mf)",
  #"7_linear_slope_all",          "ProbFlw ~ logHeight + (logHeight|block) + (logHeight|parent.pop/mf)",
  "8_quad_slope",                 "ProbFlw ~ logHeight + I(logHeight^2) + (1|block) + (1|pop.mf) + (logHeight+I(logHeight^2)|parent.pop)"
)

#run the models 
#mod_test <- glmer(ProbFlw ~ logHeight + I(logHeight^2) + (1|block) + (1|pop.mf) + (logHeight+I(logHeight^2)|parent.pop), family="binomial", data=probFlw_size)
#summary(mod_test)
#boundary (singular) fit: see help('isSingular') due to mf explaining 0 var 
#Error: pwrssUpdate did not converge in (maxit) iterations for 4_cubic_size
#Warning: failure to converge in 10000 evaluationsWarning: convergence code 4 from Nelder_Mead: failure to converge in 10000 evaluationsWarning: Model failed to converge with max|grad| = 0.0524173 (tol = 0.002, component 1) for 6_linear_slope_popmf
#Warning: failure to converge in 10000 evaluationsWarning: convergence code 4 from Nelder_Mead: failure to converge in 10000 evaluationsWarning: unable to evaluate scaled gradientWarning: Model failed to converge: degenerate  Hessian with 1 negative eigenvalues for 7_linear_slope_all

fec0.models <- fec0.models %>%
  mutate(glmer = map(f, ~ glmer(as.formula(.), 
                            data = probFlw_size, 
                            family = "binomial")), #run the models 
         predict = map(glmer, predict, type = "response", re.form = ~ (1|parent.pop)), 
         glance = map(glmer, tidy),
         AIC = map(glmer, AIC),
         BIC = map(glmer, BIC)) #glance at the model results

fec0.models %>% select(-f, -glmer, -predict) %>% filter(name=="1a_intercept_pop_mf_block" | name=="1b_intercept_pop_mf_block2") %>% unnest(glance) #the two models match as they should 
fec0.models %>% select(-f, -glmer, -predict) %>% unnest(BIC) %>% arrange(BIC) #look at the model fitting info 
fec0.models %>% select(-f, -glmer, -predict) %>% unnest(AIC) %>% arrange(AIC) #look at the model fitting info 

#2_linear_size_pop_mf_block best by BIC and AIC 
```

#### Final Model
```{r}
probFlw.final_random <- fec0.models %>% filter(name == "2_linear_size_pops_mf_block") %>% pull(glmer) %>% magrittr::extract2(1)
summary(probFlw.final_random)
```

#### Predicted vs. Observed

Note that this is with the transformed height

```{r}
probFlw_size %>% 
  mutate(pred_fixef = predict(probFlw.final_random, newdata = ., type="response", re.form = NA), 
        pred_ranef = predict(probFlw.final_random, newdata = ., type="response", re.form = ~(1|parent.pop))) %>% 
  ggplot(aes(x = logHeight, y = ProbFlw)) +
  geom_point(alpha=.2) +
  geom_line(aes(y = pred_fixef), 
            color = "blue", 
            size = 1.2, alpha=0.3) +
  geom_line(aes(y = pred_ranef), 
            color = "green", 
            size = 1.2, alpha=0.5) +
  facet_wrap(~parent.pop, scales="free")
```

### Number Fruits/Plant Models - need to add size and 0 fruits for all individuals that did not reproduce 
```{r}
wl2_fruits_2023_size <- wl2_fruits_2023 %>% 
  select(Genotype, fruits) %>% 
  right_join(twomossize) %>% 
  drop_na(height.cm) %>% 
  mutate(logHeight=log(height.cm),
         fruits=if_else(is.na(fruits), 0, fruits)) %>% 
  unite("pop.mf", parent.pop:mf, remove = FALSE) 
head(wl2_fruits_2023_size)
```


#### Observed Patterns - check if poisson distribution appropriate 
```{r}
wl2_fruits_2023_size %>% 
  ggplot(aes(x=parent.pop, y=fruits, color=parent.pop)) +
  geom_point() +
  scale_color_viridis_d(end = 0.9) #Only TM2, rest fruit number = 0
```

#### Models - Update with correct model type 
```{r}
fruits_models_random <- tribble(
  ~name,          ~f,
  "1a_intercept_pop_mf_block",     "fruits ~ 1 + (1|parent.pop/mf) + (1|block)", 
  "1b_intercept_pop_mf_block2",    "fruits ~ 1 + (1|parent.pop) + (1|pop.mf) + (1|block)",  #should be the same as above 
  "2_linear_size_pops_mf_block",   "fruits ~ logHeight + (1|block) + (1|parent.pop/mf)", 
  "3_quadratic_size",             "fruits ~ logHeight + I(logHeight^2) + (1|block) + (1|parent.pop/mf)", 
  "4_cubic_size",                 "fruits ~ logHeight + I(logHeight^2) + I(logHeight^3) + (1|block) + (1|parent.pop/mf)",
  #"5_linear_slope_pop",           "fruits ~ logHeight + (logHeight|parent.pop) + (1|pop.mf) + (1|block)",
  "6_linear_slope_popmf",         "fruits ~ logHeight + (1|block) + (logHeight|parent.pop/mf)",
  #"7_linear_slope_all",          "fruits ~ logHeight + (logHeight|block) + (logHeight|parent.pop/mf)",
  #"8_quad_slope",                 "fruits ~ logHeight + I(logHeight^2) + (1|block) + (1|pop.mf) + (logHeight+I(logHeight^2)|parent.pop)"
)

#run the models 
#mod_test <- glmer(fruits ~ logHeight + I(logHeight^2) + (1|block) + (1|pop.mf) + (logHeight+I(logHeight^2)|parent.pop), family="poisson", data=wl2_fruits_2023_size)
#summary(mod_test)
#Warning: Model failed to converge with max|grad| = 0.024078 (tol = 0.002, component 1) for 5_linear_slope_pop 
#Warning: Model failed to converge with max|grad| = 0.570942 (tol = 0.002, component 1) for 7_linear_slope_all
#Warning: convergence code 1 from bobyqa: bobyqa -- maximum number of function evaluations exceededWarning: unable to evaluate scaled gradientWarning: Model failed to converge: degenerate  Hessian with 1 negative eigenvalues for 8_quad_slope

fruits_models_random <- fruits_models_random %>%
  mutate(glmer = map(f, ~ glmer(as.formula(.), 
                            data = wl2_fruits_2023_size, 
                            family = "poisson")), #run the models 
         predict = map(glmer, predict, type = "response", re.form = ~ (1|parent.pop)), 
         glance = map(glmer, tidy),
         AIC = map(glmer, AIC),
         BIC = map(glmer, BIC)) #glance at the model results

fruits_models_random %>% select(-f, -glmer, -predict) %>% filter(name=="1a_intercept_pop_mf_block" | name=="1b_intercept_pop_mf_block2") %>% unnest(glance) #mostly the same 
fruits_models_random %>% select(-f, -glmer, -predict) %>% unnest(BIC) %>% arrange(BIC) #look at the model fitting info 
fruits_models_random %>% select(-f, -glmer, -predict) %>% unnest(AIC) %>% arrange(AIC) #look at the model fitting info 

#2_linear_size_pops_mf_block best by BIC
#4_cubic_size best by AIC 
```

#### Final Model - need to update 
```{r}
fruits.final_random <- fruits_models_random %>% filter(name == "2_linear_size_pops_mf_block") %>% pull(glmer) %>% magrittr::extract2(1)
summary(fruits.final_random)
```

#### Predicted vs. Observed Survival
```{r}
wl2_fruits_2023_size %>% 
  mutate(pred_fixef = predict(fruits.final_random, newdata = ., type="response", re.form = NA), 
        pred_ranef = predict(fruits.final_random, newdata = ., type="response", re.form = ~(1|parent.pop))) %>% 
  ggplot(aes(x = logHeight, y = fruits)) +
  geom_point(alpha=.2) +
  geom_line(aes(y = pred_fixef), 
            color = "blue", 
            size = 1.2, alpha=0.3) +
  geom_line(aes(y = pred_ranef), 
            color = "green", 
            size = 1.2, alpha=0.5) +
  facet_wrap(~parent.pop, scales="free")
```


### F Kernel
#### Make dataframe to save reproduction-related params
```{r}
params.rep = data.frame(
  flower.int=NA, # Intercept from log reg of flowering prob 
  flower.slope = NA, # Slope from log reg of flowering prob 
  fruit.int=NA, # Intercept from Poisson regression of fruit number
  fruit.slope=NA, # Slope from Poisson regression of fruit number
  seed.per.fruit=fec2, #seeds produced per fruit
  germ.prob=fec3, #germ prob 
  establishment.prob=fec4, # Probability of establishment
  recruit.size.mean=NA, # Mean recruit size
  recruit.size.sd=NA # Standard deviation of recruit size
)
```

#### Extract the model params 
Use broom:tidy 

```{r}
fec0.coefs <- fec0.models %>% 
  filter(name == "2_linear_size_pops_mf_block") %>% 
  mutate(coefs = map(glmer, tidy)) %>% 
  select(name, f, coefs) %>% 
  unnest(coefs) 

params.rep$flower.int <- fec0.coefs %>% filter(term == "(Intercept)") %>% pull(estimate)
params.rep$flower.slope <- fec0.coefs %>% filter(term == "logHeight") %>% pull(estimate)
```

```{r}
fruits.coefs <- fruits_models_random %>% 
  filter(name == "2_linear_size_pops_mf_block") %>% 
  mutate(coefs = map(glmer, tidy)) %>% 
  select(name, f, coefs) %>% 
  unnest(coefs) 

params.rep$fruit.int <- fruits.coefs %>% filter(term == "(Intercept)") %>% pull(estimate)
params.rep$fruit.slope <- fruits.coefs %>% filter(term == "logHeight") %>%  pull(estimate) 
```

```{r}
recruit_size <- wl2_all_2023 %>% 
  filter(survey_date=="2023-07-03" | survey_date=="2023-07-06") %>% 
  summarise(recruit.size.mean=mean(height.cm, na.rm=TRUE), recruit.size.sd=sd(height.cm, na.rm = TRUE))


params.rep$recruit.size.mean <- recruit_size$recruit.size.mean
params.rep$recruit.size.sd <- recruit_size$recruit.size.sd
```


#### Define the functions
```{r}
# flowering prob. function 
p.flower.x=function(x,params.rep) { #flowering prob. 
              u=exp(params.rep$flower.int+params.rep$flower.slope*x)
              return(u/(1+u)) #back transform from logit scale 
}
```

```{r}
#fruit number function
fruit.n <- function(x, params.rep) {
  exp(params.rep$fruit.int + 
        x*params.rep$fruit.slope) #fecundity, exp to backtransform poisson 
}
```

```{r}
#reproduction function (with above prob. and fruit functions incorporated)
f.yx=function(xp,x,params.rep) {
  #fresh seeds:
  p.flower.x(x,params.rep)* #have to flower first
    fruit.n(x, params.rep)* #then produce a certain number of fruits 
    params.rep$seed.per.fruit* #those fruits have a certain number of seeds 
    params.rep$germ.prob* #those seeds have to germinate
              params.rep$establishment.prob* #recruits have to surv post germ
              dnorm(xp,mean=params.rep$recruit.size.mean,sd=params.rep$recruit.size.sd) 
}
```

#### Make the F matrix
```{r}
F=h*outer(y,y,f.yx,params=params.rep) # reproduction matrix
```

#### Plot the F matrix 
```{r}
F %>% as_tibble() %>%
  set_colnames(y) %>% #column names = each size mesh point 
  mutate(size.t1=y) %>%
  pivot_longer(-size.t1, names_to = "size.t", names_transform = as.numeric) %>%
  ggplot(aes(x=size.t, y = size.t1)) +
  geom_raster(aes(fill = value)) + #basic contour with fill determined by the growth*surv value 
  geom_contour(aes(z = value),lwd=.25) + #adds contour lines 
  geom_abline(intercept=0, slope = 1, color="gray90", lty=5) + #add 1:1 line 
  scale_fill_viridis_c(option = "plasma") + #change contour colors 
  labs(x = "Size (t)", y = "Size (t + 1)", title = "F Matrix: Fecundity") +
  coord_equal() + #make it a square plot 
  theme_bw()
```

## Combine P and F matrices to make the IPM (K Matrix)
```{r}
K=P+F                             # full matrix 
(lam=Re(eigen(K)$values[1]))      # population growth rate
```

### Plot the matrix
```{r}
K %>% as_tibble() %>%
   set_colnames(y) %>% #column names = each size mesh point 
  mutate(size.t1=y) %>%
  pivot_longer(-size.t1, names_to = "size.t", names_transform = as.numeric) %>%
  ggplot(aes(x=size.t, y = size.t1)) +
  geom_raster(aes(fill = value)) + #basic contour with fill determined by the growth*surv value 
  geom_contour(aes(z = value),lwd=.25) + #adds contour lines 
  geom_abline(intercept=0, slope = 1, color="gray90", lty=5) + #add 1:1 line 
  scale_fill_viridis_c(option = "plasma") + #change contour colors 
  labs(x = "Size (t)", y = "Size (t + 1)", title = "WL2 IPM 2023") +
  coord_equal() + #make it a square plot 
  theme_bw()
```
